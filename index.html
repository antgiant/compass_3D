<!DOCTYPE html>
<html lang="en">

<head>
	<title>Live Ball Compass</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<style>
		body {
			background: #000;
			color: #eee;
		}
		
		a {
			color: #0080ff;
		}
		
		b {
			color: orange
		}
		
		[class^="column-"] {
			display: inline-block;
		}
		
		.column-33 {
			width: 33.33333%;
		}
		
		.status {
			position: fixed;
			left: 0;
			right: 0;
			bottom: 0;
		}
		
		.position {
			padding-bottom: 0.5rem;
			text-transform: uppercase;
			text-align: center;
		}
	</style>
</head>

<body>
	
	<div id="info">Ball Compass<br />
	</div>
	
	<!-- Import maps polyfill -->
	<!-- Remove this when import maps will be widely supported -->
	<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
	
	<script type="importmap">
		{
				"imports": {
					"three": "./build/three.module.js"
				}
			}
		</script>
	
	<script type="module">
		import * as THREE from 'three';
		
		import Stats from './jsm/libs/stats.module.js';
		
		import { OrbitControls } from './jsm/controls/OrbitControls.js';
		import { EffectComposer } from './jsm/postprocessing/EffectComposer.js';
		import { RenderPass } from './jsm/postprocessing/RenderPass.js';
		import { FilmPass } from './jsm/postprocessing/FilmPass.js';
		
		const radius = 100;
		const tilt = 0.41;
		const rotationSpeed = 1.02;
		
		const MARGIN = 0;
		let SCREEN_HEIGHT = window.innerHeight - MARGIN * 2;
		let SCREEN_WIDTH = window.innerWidth;
		
		let camera, scene, renderer, stats, controls;
		let geometry, meshCompass, shinyBallGeom, shinyBallMesh;
		let dirLight, dirLight2, dirLight3, dirLight4, dirLight5, dirLight6;
		
		let composer;
		
		// our current position
		let positionCurrent = {
			lat: null,
			lng: null,
			hng: null
		};
		
		// elements that ouput our position
		var positionLat = document.getElementById("position-lat");
		var positionLng = document.getElementById("position-lng");
		var positionHng = document.getElementById("position-hng");
		var positionAlpha = document.getElementById("alpha");
		var positionBeta = document.getElementById("beta");
		var positionGamma = document.getElementById("gamma");
		var positionCompass = document.getElementById("compass");
		
		const textureLoader = new THREE.TextureLoader();
		
		let d, dPlanet;
		
		const clock = new THREE.Clock();
		
		init();
		animate();
		
		function init() {
			
			camera = new THREE.PerspectiveCamera(25, SCREEN_WIDTH / SCREEN_HEIGHT, 50, 1e7);
			camera.position.z = radius * 7;
			
			scene = new THREE.Scene();
			//scene.fog = new THREE.FogExp2( 0x000000, 0.00000025 );
			
			dirLight = new THREE.DirectionalLight(0xffffff);
			dirLight.position.set(-1, 0, 1).normalize();
			scene.add(dirLight);
			
			dirLight2 = new THREE.DirectionalLight(0xffffff);
			dirLight2.position.set(1, 0, 1).normalize();
			scene.add(dirLight2);
			
			dirLight3 = new THREE.DirectionalLight(0xffffff);
			dirLight3.position.set(-1, 0, -1).normalize();
			scene.add(dirLight3);
			
			dirLight4 = new THREE.DirectionalLight(0xffffff);
			dirLight4.position.set(1, 0, -1).normalize();
			scene.add(dirLight4);
			
			dirLight5 = new THREE.DirectionalLight(0xffffff);
			dirLight5.position.set(0, 1, 0).normalize();
			scene.add(dirLight5);
			
			dirLight6 = new THREE.DirectionalLight(0xffffff);
			dirLight6.position.set(0, -1, 0).normalize();
			scene.add(dirLight6);
			
			const materialNormalMap = new THREE.MeshPhongMaterial({
				
				specular: 0x333333,
				shininess: 15,
				map: textureLoader.load("textures/ball_compass.jpg"),
				//specularMap: textureLoader.load( "textures/ball_compass.jpg" ),
				//normalMap: textureLoader.load( "textures/ball_compass.jpg" ),
				
				// y scale is negated to compensate for normal map handedness.
				normalScale: new THREE.Vector2(1, -1)
				
			});
			
			// compass
			
			geometry = new THREE.SphereGeometry(radius, 100, 100);
			
			// shift the texture’s “north” to match Y-rotation
			geometry.rotateY(Math.PI / 2);
			
			
			meshCompass = new THREE.Mesh(geometry, materialNormalMap);
			scene.add(meshCompass);
			
			// Shiny Glass Ball
			
			const roughNormal = textureLoader.load("textures/Water_2_M_Normal.jpeg");
			const clearcoatNormal = textureLoader.load(
				"textures/Scratched_gold_01_1K_Normal.png"
			);
			
			const shinyBallNormalMap = new THREE.MeshPhysicalMaterial({
				normalMap: roughNormal,
				clearcoat: 1,
				clearcoatNormalMap: clearcoatNormal,
				roughness: 0.0515,
				transmission: 1,
				thickness: 0.05
			});
			shinyBallGeom = new THREE.SphereGeometry(radius + (radius * 0.05), 100, 100);
			shinyBallMesh = new THREE.Mesh(shinyBallGeom, shinyBallNormalMap);
			scene.add(shinyBallMesh);
			
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
			document.body.appendChild(renderer.domElement);
			
			//
			
			controls = new OrbitControls(camera, renderer.domElement);
			
			controls.domElement = renderer.domElement;
			
			//
			
			stats = new Stats();
			document.body.appendChild(stats.dom);
			
			window.addEventListener('resize', onWindowResize);
			
			// postprocessing
			
			const renderModel = new RenderPass(scene, camera);
			const effectFilm = new FilmPass(0.35, 0.75, 2048, false);
			
			composer = new EffectComposer(renderer);
			
			composer.addPass(renderModel);
			composer.addPass(effectFilm);
			
		}
		
		function onWindowResize() {
			
			SCREEN_HEIGHT = window.innerHeight;
			SCREEN_WIDTH = window.innerWidth;
			
			camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
			camera.updateProjectionMatrix();
			
			renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
			composer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
			
		}
		
		function animate() {
			
			requestAnimationFrame(animate);
			
			render();
			stats.update();
			
		}
		
		function render() {
			
			// rotate the compass
			
			const delta = clock.getDelta();
			
			//meshCompass.rotation.y += rotationSpeed * delta;
			
			composer.render(delta);
			
		}
		
		// browser agnostic orientation
		function getBrowserOrientation() {
			var orientation;
			if (screen.orientation && screen.orientation.type) {
				orientation = screen.orientation.type;
			} else {
				orientation = screen.orientation ||
					screen.mozOrientation ||
					screen.msOrientation;
			}
			
			/*
			  'portait-primary':      for (screen width < screen height, e.g. phone, phablet, small tablet)
			                            device is in 'normal' orientation
			                          for (screen width > screen height, e.g. large tablet, laptop)
			                            device has been turned 90deg clockwise from normal

			  'portait-secondary':    for (screen width < screen height)
			                            device has been turned 180deg from normal
			                          for (screen width > screen height)
			                            device has been turned 90deg anti-clockwise (or 270deg clockwise) from normal

			  'landscape-primary':    for (screen width < screen height)
			                            device has been turned 90deg clockwise from normal
			                          for (screen width > screen height)
			                            device is in 'normal' orientation

			  'landscape-secondary':  for (screen width < screen height)
			                            device has been turned 90deg anti-clockwise (or 270deg clockwise) from normal
			                          for (screen width > screen height)
			                            device has been turned 180deg from normal
			*/
			
			return orientation;
		}
		
		function computeHeadingFromOrientation(event) {
			// Prefer a fused + tilt-compensated heading if the browser provides it (iOS Safari).
			if (typeof event.webkitCompassHeading === 'number') {
				// iOS gives 0 = North, clockwise positive.
				return (360 - event.webkitCompassHeading + (screen.orientation?.angle ?? 0)) % 360;
			}
			
			// Otherwise, build a quaternion from alpha/beta/gamma and screen orientation.
			const deg2rad = Math.PI / 180;
			const alpha = (event.alpha || 0) * deg2rad; // z
			const beta = (event.beta || 0) * deg2rad; // x
			const gamma = (event.gamma || 0) * deg2rad; // y
			const so = ((screen.orientation?.angle ?? 0) * deg2rad);
			
			// Use the same convention as DeviceOrientationControls: order 'YXZ'
			// q = R_y(alpha) * R_x(beta) * R_z(gamma)
			const euler = new THREE.Euler(beta, alpha, -gamma, 'YXZ');
			const q = new THREE.Quaternion().setFromEuler(euler);
			
			// Apply screen orientation (rotate about world Z by -so)
			const qScreen = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), -so);
			q.premultiply(qScreen);
			
			// Transform a forward vector and project onto the horizontal plane (X–Y)
			const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(q);
			fwd.z = 0;
			if (fwd.lengthSq() < 1e-6) return 0; // fallback if near-vertical straight up/down
			fwd.normalize();
			
			// Convert to compass bearing: 0° = North (+Y), clockwise positive
			let heading = Math.atan2(fwd.x, fwd.y) * 180 / Math.PI;
			if (heading < 0) heading += 360;
			return heading;
		}
		
		function computeYawPitch(event) {
			// Build device orientation quaternion (same conv. as DeviceOrientationControls)
			const d2r = Math.PI / 180;
			const alpha = (event.alpha || 0) * d2r; // z
			const beta = (event.beta || 0) * d2r; // x
			const gamma = (event.gamma || 0) * d2r; // y
			const so = (screen.orientation?.angle ?? 0) * d2r;
			
			// q = R_y(alpha) * R_x(beta) * R_z(gamma)   with order 'YXZ'
			const euler = new THREE.Euler(beta, alpha, -gamma, 'YXZ');
			const q = new THREE.Quaternion().setFromEuler(euler);
			
			// Apply screen orientation (rotate around world Z by -so)
			const qScreen = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), -so);
			const qTotal = qScreen.multiply(q);
			
			// Transform world-forward (0,0,-1) and right (1,0,0)
			const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(qTotal); // device forward in world
			const right = new THREE.Vector3(1, 0, 0).applyQuaternion(qTotal); // device right in world
			
			// ---- Yaw: angle in the horizontal (X–Z) plane, 0° = world -Z (forward), clockwise positive
			// If you want 0°=North and North is -Z, this works:
			let yaw = Math.atan2(fwd.x, -fwd.z); // [-π, π]
			
			// ---- Pitch: up/down tilt. Use the world-up (Y) component of forward.
			//   asin(fwd.y) is stable and avoids roll coupling.
			let pitch = Math.asin(THREE.MathUtils.clamp(fwd.y, -1, 1)); // [-π/2, π/2]
			
			// Optional: smooth or clamp if you want limited tilt
			return { yawDeg: THREE.MathUtils.radToDeg(yaw), pitchDeg: THREE.MathUtils.radToDeg(pitch) };
		}
		
		function computeHeadingFromOrientation(event) {
			// Prefer fused, tilt-compensated heading on iOS if available
			if (typeof event.webkitCompassHeading === 'number') {
				return (360 - event.webkitCompassHeading + (screen.orientation?.angle ?? 0)) % 360;
			}
			// From yaw above (0..360, clockwise, 0 = North == -Z)
			const { yawDeg } = computeYawPitch(event);
			let heading = yawDeg;
			if (heading < 0) heading += 360;
			return heading;
		}
		
		function onHeadingChange(event) {
			const heading = computeHeadingFromOrientation(event); // 0..360
			const { yawDeg, pitchDeg } = computeYawPitch(event); // yaw & pitch only
			
			positionHng.textContent = heading.toFixed(0) + '°';
			positionCompass.textContent = heading.toFixed(1);
			positionAlpha.textContent = (event.alpha ?? 0).toFixed(1);
			positionBeta.textContent = (event.beta ?? 0).toFixed(1);
			positionGamma.textContent = (event.gamma ?? 0).toFixed(1);
			
			// Apply to the mesh: (pitch around X, yaw around Y, roll = 0)
			meshCompass.rotation.set(
				THREE.MathUtils.degToRad(pitchDeg),
				THREE.MathUtils.degToRad(yawDeg),
				0
			);
		}
		
		function locationUpdate(position) {
			positionCurrent.lat = position.coords.latitude;
			positionCurrent.lng = position.coords.longitude;
			
			positionLat.textContent = decimalToSexagesimal(positionCurrent.lat, "lat");
			positionLng.textContent = decimalToSexagesimal(positionCurrent.lng, "lng");
		}
		
		function locationUpdateFail(error) {
			positionLat.textContent = "n/a";
			positionLng.textContent = "n/a";
			console.log("location fail: ", error);
		}
		
		function decimalToSexagesimal(decimal, type) {
			var degrees = decimal | 0;
			var fraction = Math.abs(decimal - degrees);
			var minutes = (fraction * 60) | 0;
			var seconds = (fraction * 3600 - minutes * 60) | 0;
			
			var direction = "";
			var positive = degrees > 0;
			degrees = Math.abs(degrees);
			switch (type) {
				case "lat":
					direction = positive ? "N" : "S";
					break;
				case "lng":
					direction = positive ? "E" : "W";
					break;
			}
			
			return degrees + "° " + minutes + "' " + seconds + "\" " + direction;
		}
		
		function requestDeviceOrientation(callback) {
			if (window.DeviceOrientationEvent == null) {
				callback(new Error("DeviceOrientation is not supported."));
			} else if (DeviceOrientationEvent.requestPermission) {
				DeviceOrientationEvent.requestPermission().then(function(state) {
					if (state == "granted") {
						callback(null);
					} else callback(new Error("Permission denied by user"));
				}, function(err) {
					callback(err);
				});
			} else { // no need for permission
				callback(null);
			}
		}
		
		function firstClick() {
			requestDeviceOrientation(function(err) {
				if (err == null) {
					window.removeEventListener("click", firstClick);
					window.removeEventListener("touchend", firstClick);
					window.addEventListener("devicemotion", function(e) {
						// access e.acceleration, etc.
					});
				} else {
					// failed; a JS error object is stored in `err`
				}
			});
		}
		window.addEventListener("click", firstClick);
		window.addEventListener("touchend", firstClick);
		
		if ('ondeviceorientationabsolute' in window) {
			window.addEventListener("deviceorientationabsolute", onHeadingChange, true);
		} else {
			window.addEventListener("deviceorientation", onHeadingChange, true);
		}
		
		navigator.geolocation.watchPosition(locationUpdate, locationUpdateFail, {
			enableHighAccuracy: false,
			maximumAge: 30000,
			timeout: 27000
		});
	</script>
	<div class="status">
		<div class='position row'>
			<div class='column-33'>
				<div class='label'>HDG</div>
				<div id='position-hng'>n/a</div>
			</div>
			<div class='column-33'>
				<div class='label'>Lat</div>
				<div id='position-lat'>&#8943;</div>
			</div>
			<div class='column-33'>
				<div class='label'>Lng</div>
				<div id='position-lng'>&#8943;</div>
			</div>
		</div>
		<div class='position row'>
			<div class='column-33'>
				<div class='label'>Alpha</div>
				<div id='alpha'>n/a</div>
			</div>
			<div class='column-33'>
				<div class='label'>Beta</div>
				<div id='beta'>&#8943;</div>
			</div>
			<div class='column-33'>
				<div class='label'>Gamma</div>
				<div id='gamma'>&#8943;</div>
			</div>
		</div>
		<div class='position row'>
			<div class='column-33'>
				<div class='label'>Compass</div>
				<div id='compass'>n/a</div>
			</div>
		</div>
	</div>
</body>

</html>